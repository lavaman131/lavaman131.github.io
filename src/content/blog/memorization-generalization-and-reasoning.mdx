---
title: "Memorization, Generalization, and Reasoning"
date: "2025-06-20"
authors: "Alex Lavaee, Norin Lavaee"
description: "A deep dive into the concepts of memorization, generalization, and reasoning in large language models."
---

Not understanding how AI models actually memorize, generalize, and reason is costing us. We're chasing the wrong problems instead of building real solutions.

## How much do models actually memorize?

Meta's research "How much do language models memorize?" provides crucial insights. They distinguished between **unintended memorization** (training set specifics) and **generalization** (true pattern recognition).

**Key Finding**: GPT-family models (examining GPT-2 series) memorize ~3.6 bits per parameter. Researchers trained target models on uniformly random bit strings and used reference models trained on larger, diverse datasets. They leveraged Shannon Information Theory (less likely events carry more information) to approximate Kolmogorov Complexity (shortest description length needed to reproduce an object). Since compression rates are tied to likelihood in predictive models, they approximated Kolmogorov complexity using model likelihoods.

**The Formula**: `compression_bits(reference_model) - compression_bits(trained_model) = unintended memorization` or the information from specific datasets stored in trained model weights. Higher probability means less surprise (information), resulting in fewer compression_bits based on the Shannon Entropy equation.

<div style={{ marginTop: '2rem', marginBottom: '2rem' }}>
  <iframe
    srcDoc={`<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Memorization Measurement Visualization</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f5f5f5;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        .section {
            background: white;
            margin: 20px 0;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .model-box {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px;
            border-radius: 8px;
            margin: 10px;
            text-align: center;
            min-width: 200px;
            display: inline-block;
        }
        .text-sample {
            background: #fff3cd;
            border: 2px solid #ffeaa7;
            padding: 15px;
            border-radius: 8px;
            margin: 10px 0;
            font-family: monospace;
        }
        .compression-bar {
            width: 100%;
            height: 30px;
            background: #e0e0e0;
            border-radius: 15px;
            position: relative;
            margin: 10px 0;
        }
        .compression-fill {
            height: 100%;
            border-radius: 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            min-width: 140px;
        }
        .high-compression { background: linear-gradient(90deg, #ff6b6b, #ee5a52); }
        .medium-compression { background: linear-gradient(90deg, #feca57, #ff9ff3); }
        .low-compression { background: linear-gradient(90deg, #48dbfb, #0abde3); }
        
        .flow-diagram {
            display: flex;
            align-items: center;
            justify-content: space-around;
            flex-wrap: wrap;
            margin: 20px 0;
        }
        .arrow {
            font-size: 24px;
            color: #666;
            margin: 0 10px;
        }
        .measurement-box {
            background: #f8f9fa;
            border: 2px solid #dee2e6;
            padding: 15px;
            border-radius: 8px;
            margin: 10px;
            text-align: center;
        }
        .memorization-result {
            background: linear-gradient(135deg, #ff6b6b, #ee5a52);
            color: white;
            padding: 20px;
            border-radius: 8px;
            text-align: center;
            font-size: 18px;
            font-weight: bold;
        }
        .interactive-demo {
            background: #e8f5e8;
            border: 2px solid #4CAF50;
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
        }
        .slider-container {
            margin: 15px 0;
        }
        .slider {
            width: 100%;
            margin: 10px 0;
        }
        .probability-display {
            font-family: monospace;
            font-size: 16px;
            background: #fff;
            padding: 10px;
            border-radius: 4px;
            margin: 10px 0;
        }
        h1, h2 {
            color: #333;
        }
        .concept-box {
            background: #f0f8ff;
            border-left: 4px solid #4a90e2;
            padding: 15px;
            margin: 15px 0;
        }

    </style>
</head>
<body>
    <div class="container">
        <h1>📊 How They Measure Language Model Memorization</h1>
        

        
        <div class="section">
            <h2>1. The Basic Setup</h2>
            <div class="concept-box">
                <strong>Key Idea:</strong> Compare how well two different models can compress the same text. Better compression = more memorization.
            </div>
            
            <div class="flow-diagram">
                <div class="model-box">
                    <h3>Reference Model</h3>
                    <p>Trained on diverse, large dataset</p>
                    <p><em>Represents "general knowledge"</em></p>
                </div>
                <div class="arrow">vs</div>
                <div class="model-box">
                    <h3>Target Model</h3>
                    <p>Trained on specific dataset</p>
                    <p><em>Has general knowledge + memorization</em></p>
                </div>
            </div>
        </div>

        <div class="section">
            <h2>2. Step-by-Step Measurement Process</h2>
            
            <div class="text-sample">
                <strong>Test Text:</strong> "The quick brown fox jumps over the lazy dog"
            </div>
            
            <h3>Step 1: Test Reference Model</h3>
            <div class="measurement-box">
                <p><strong>Reference Model Probability:</strong> 0.01 (1%)</p>
                <p><strong>Compression Cost:</strong> -log₂(0.01) = 6.64 bits</p>
            </div>
            
            <div class="compression-bar">
                <div class="compression-fill low-compression" style="width: 66%;">
                    6.64 bits needed
                </div>
            </div>
            
            <h3>Step 2: Test Target Model</h3>
            <div class="measurement-box">
                <p><strong>Target Model Probability:</strong> 0.25 (25%)</p>
                <p><strong>Compression Cost:</strong> -log₂(0.25) = 2.00 bits</p>
            </div>
            
            <div class="compression-bar">
                <div class="compression-fill high-compression" style="width: 20%;">
                    2.00 bits needed
                </div>
            </div>
            
            <h3>Step 3: Calculate Memorization</h3>
            <div class="memorization-result">
                Memorization = 6.64 - 2.00 = 4.64 bits
                <br><small>The target model "knows" 4.64 bits more about this text!</small>
            </div>
        </div>

        <div class="section">
            <h2>3. Interactive Demo: See How Probability Affects Compression</h2>
            <div class="interactive-demo">
                <p>Adjust the model's probability for a text sequence and see how it affects compression:</p>
                
                <div class="slider-container">
                    <label>Model's Probability for the text: <span id="prob-value">10%</span></label>
                    <input type="range" id="prob-slider" class="slider" min="1" max="100" value="10">
                </div>
                
                <div class="probability-display">
                    <div>Probability: <span id="prob-decimal">0.10</span></div>
                    <div>Compression Cost: <span id="compression-cost">3.32</span> bits</div>
                    <div>Interpretation: <span id="interpretation">Moderate compression</span></div>
                </div>
                
                <div class="compression-bar">
                    <div id="compression-visual" class="compression-fill medium-compression" style="width: 33%;">
                        <span id="compression-text">3.32 bits</span>
                    </div>
                </div>
                
                <p><small><strong>Remember:</strong> Higher probability → Better compression → More memorization</small></p>
            </div>
        </div>

        <div class="section">
            <h2>4. Real Results from the Paper</h2>
            
            <h3>Different Types of Memorization:</h3>
            
            <div style="display: flex; justify-content: space-around; flex-wrap: wrap;">
                <div class="measurement-box" style="background: #ffebee;">
                    <h4>🔴 High Memorization</h4>
                    <p><strong>Example:</strong> Rare sequences, foreign text</p>
                    <div class="compression-bar">
                        <div class="compression-fill high-compression" style="width: 15%;">
                            1-2 bits
                        </div>
                    </div>
                    <p><small>Model assigns very high probability</small></p>
                </div>
                
                <div class="measurement-box" style="background: #fff3e0;">
                    <h4>🟡 Medium Memorization</h4>
                    <p><strong>Example:</strong> Common phrases, typical sentences</p>
                    <div class="compression-bar">
                        <div class="compression-fill medium-compression" style="width: 40%;">
                            3-4 bits
                        </div>
                    </div>
                    <p><small>Model has some specific knowledge</small></p>
                </div>
                
                <div class="measurement-box" style="background: #e8f5e8;">
                    <h4>🟢 Low/No Memorization</h4>
                    <p><strong>Example:</strong> Truly random sequences</p>
                    <div class="compression-bar">
                        <div class="compression-fill low-compression" style="width: 70%;">
                            6+ bits
                        </div>
                    </div>
                    <p><small>Model treats it like any other text</small></p>
                </div>
            </div>
        </div>

        <div class="section">
            <h2>5. Why This Method Works</h2>
            <div class="concept-box">
                <h3>🎯 The Intuition:</h3>
                <ul>
                    <li><strong>If a model can compress text really well</strong> → it has "seen" or "learned" something specific about that text</li>
                    <li><strong>If two models compress differently</strong> → the difference shows what one model memorized that the other didn't</li>
                    <li><strong>Better compression = higher probability = more memorization</strong></li>
                </ul>
            </div>
            
            <div class="concept-box">
                <h3>📏 What the Numbers Mean:</h3>
                <ul>
                    <li><strong>0-1 bits difference:</strong> Minimal memorization (normal generalization)</li>
                    <li><strong>2-4 bits difference:</strong> Moderate memorization (model has some specific knowledge)</li>
                    <li><strong>5+ bits difference:</strong> High memorization (model has strong specific knowledge)</li>
                </ul>
            </div>
        </div>
    </div>

    <script>
        const probSlider = document.getElementById('prob-slider');
        const probValue = document.getElementById('prob-value');
        const probDecimal = document.getElementById('prob-decimal');
        const compressionCost = document.getElementById('compression-cost');
        const interpretation = document.getElementById('interpretation');
        const compressionVisual = document.getElementById('compression-visual');
        const compressionText = document.getElementById('compression-text');

        function updateCompression() {
            const prob = parseInt(probSlider.value);
            const decimal = prob / 100;
            const cost = -Math.log2(decimal);
            const width = Math.min(cost * 10, 100);
            
            probValue.textContent = prob + '%';
            probDecimal.textContent = decimal.toFixed(2);
            compressionCost.textContent = cost.toFixed(2);
            compressionText.textContent = cost.toFixed(2) + ' bits';
            
            // Update interpretation
            if (cost < 2) {
                interpretation.textContent = 'Excellent compression (high memorization!)';
                compressionVisual.className = 'compression-fill high-compression';
            } else if (cost < 4) {
                interpretation.textContent = 'Good compression (moderate memorization)';
                compressionVisual.className = 'compression-fill medium-compression';
            } else {
                interpretation.textContent = 'Poor compression (little memorization)';
                compressionVisual.className = 'compression-fill low-compression';
            }
            
            compressionVisual.style.width = width + '%';
        }

        probSlider.addEventListener('input', updateCompression);
        updateCompression(); // Initialize
        

    </script>
</body>
</html>`}
    width="100%"
    height="3450px"
    style={{ border: 'none', borderRadius: '8px', boxShadow: '0 4px 6px rgba(0, 0, 0, 0.1)' }}
    title="Shannon Information Theory Visualization"
  />
</div>

**Shannon Information Theory Algorithm:**

```javascript
// Shannon Information Theory - The Core Algorithm
// This calculates how many bits are needed to compress information

updateCompression() {
    // Get probability as percentage (1-100%)
    const prob = parseInt(probSlider.value);
    
    // Convert to decimal probability (0.01-1.0)
    const decimal = prob / 100;
    
    // 🎯 SHANNON ENTROPY FORMULA: -log₂(probability)
    // Lower probability = More surprise = More bits needed
    const cost = -Math.log2(decimal);
    
    // The difference in compression costs between models
    // reveals how much one model "memorized" vs the other
    const memorization = referenceModelCost - targetModelCost;
    
    // Visual representation for the progress bar
    const width = Math.min(cost * 10, 100);
}

// Key Insight: If a model assigns high probability to text,
// it needs fewer bits to compress it = more memorization!

// Examples:
// 100% probability → 0 bits (perfect memorization)
// 50% probability → 1 bit (some memorization)
// 1% probability → ~6.6 bits (little/no memorization)
```

<br />

**Critical Insight**: Once memorization capacity fills, training shifts to learning general patterns where 'grokking' begins. Models are forced to generalize. Scaling laws demonstrate that modern LLMs are trained on such vast datasets that membership reference (pulling out specifics) becomes extremely rare for average data points.

## How does reasoning come into play?

Apple's recent paper "The Illusion of Thinking" claimed models "collapse" on complex reasoning tasks, with non-reasoning models outperforming reasoning ones on simple tasks. However, "The Illusion of Illusion of Thinking" paper revealed critical experimental design flaws:

### Prompt Design
Apple's prompts asked models to enumerate every Tower of Hanoi move, causing output token limits where models explicitly stated "The pattern continues, but to avoid making this too long, I'll stop here." When prompted to generate functions instead ("Output a Lua function that prints the solution when called"), Claude Opus, Sonnet, and Gemini correctly produced recursive algorithms for 15-disk solutions.

### Unsolvable Problems
Apple marked models as failures for not solving mathematically impossible River Crossing puzzles (N ≥ 6 with boat capacity of 3).

Both sides acknowledge that current models have real output limitations, but experimental design can make those limits appear more fundamental than they are.

Here's an example of successfully solving the Tower of Hanoi algorithmically using AI:

<div style={{ marginTop: '2rem', marginBottom: '2rem' }}>
  <iframe
    srcDoc={`<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tower of Hanoi Solver</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            min-height: 100vh;
            overflow: hidden;
        }

        .container {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        h1 {
            text-align: center;
            margin-bottom: 30px;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        .controls {
            text-align: center;
            margin-bottom: 30px;
            display: flex;
            gap: 15px;
            justify-content: center;
            align-items: center;
            flex-wrap: wrap;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        label {
            font-weight: 600;
            font-size: 1.1em;
        }

        input, button, select {
            padding: 10px 15px;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
        }

        input, select {
            background: rgba(255, 255, 255, 0.9);
            color: #333;
            width: 80px;
        }

        button {
            background: linear-gradient(45deg, #ff6b6b, #ee5a24);
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
        }

        button:disabled {
            background: #666;
            cursor: not-allowed;
            transform: none;
        }

        .game-area {
            display: flex;
            justify-content: space-around;
            align-items: flex-end;
            min-height: 300px;
            height: auto;
            margin: 40px 0;
            background: rgba(0, 0, 0, 0.1);
            border-radius: 15px;
            padding: 20px;
        }

        .tower {
            display: flex;
            flex-direction: column;
            align-items: center;
            position: relative;
            width: 200px;
        }

        .tower-base {
            width: 180px;
            height: 20px;
            background: linear-gradient(45deg, #8B4513, #A0522D);
            border-radius: 10px;
            margin-top: 10px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            position: relative;
            z-index: 1;
        }

        .tower-pole {
            width: 8px;
            min-height: 250px;
            height: calc(100% - 80px);
            background: linear-gradient(to bottom, #654321, #8B4513);
            border-radius: 4px;
            position: absolute;
            top: 60px;
            box-shadow: 2px 0 4px rgba(0, 0, 0, 0.3);
            z-index: 2;
        }

        .tower-label {
            font-size: 1.5em;
            font-weight: bold;
            margin-bottom: 20px;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
            position: relative;
            z-index: 10;
            background: rgba(255, 255, 255, 0.1);
            padding: 8px 16px;
            border-radius: 12px;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .disk {
            height: 20px;
            border-radius: 10px;
            margin: 1px 0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            color: white;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
            position: relative;
            z-index: 20;
            font-size: 0.8em;
        }

        .tower-content {
            display: flex;
            flex-direction: column-reverse;
            align-items: center;
            position: relative;
            min-height: 220px;
            height: auto;
            justify-content: flex-end;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin: 30px 0;
        }

        .stat-card {
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 15px;
            text-align: center;
            backdrop-filter: blur(5px);
        }

        .stat-value {
            font-size: 2em;
            font-weight: bold;
            color: #ffd700;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }



        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .moving {
            transform: translateY(-50px);
            z-index: 100;
        }


    </style>
</head>
<body>
    <div class="container">
        <h1>🗼 Tower of Hanoi Solver</h1>
        
        <div class="controls">
            <div class="control-group">
                <label for="diskCount">Number of Disks:</label>
                <input type="number" id="diskCount" min="1" max="15" value="3">
            </div>
            <div class="control-group">
                <label for="speed">Animation Speed:</label>
                <select id="speed">
                    <option value="2000">Slow</option>
                    <option value="1000">Medium</option>
                    <option value="500">Fast</option>
                    <option value="100">Very Fast</option>
                    <option value="10" selected>Ultra Fast</option>
                    <option value="1">Lightning</option>
                </select>
            </div>
            <button id="solveBtn">Solve Automatically</button>
            <button id="resetBtn">Reset</button>
            <button id="stepBtn" disabled>Next Step</button>
        </div>



        <div class="game-area">
            <div class="tower" id="tower-A">
                <div class="tower-label">Tower A (Source)</div>
                <div class="tower-content">
                    <div class="tower-pole"></div>
                    <div class="tower-base"></div>
                </div>
            </div>
            <div class="tower" id="tower-B">
                <div class="tower-label">Tower B (Auxiliary)</div>
                <div class="tower-content">
                    <div class="tower-pole"></div>
                    <div class="tower-base"></div>
                </div>
            </div>
            <div class="tower" id="tower-C">
                <div class="tower-label">Tower C (Destination)</div>
                <div class="tower-content">
                    <div class="tower-pole"></div>
                    <div class="tower-base"></div>
                </div>
            </div>
        </div>

        <div class="stats">
            <div class="stat-card">
                <div class="stat-value" id="moveCount">0</div>
                <div>Moves Made</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="minMoves">7</div>
                <div>Minimum Moves</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="totalTime">0</div>
                <div>Time (seconds)</div>
            </div>
        </div>


    </div>

    <script>
        class TowerOfHanoi {
            constructor() {
                this.towers = { A: [], B: [], C: [] };
                this.moves = [];
                this.currentMoveIndex = 0;
                this.moveCount = 0;
                this.isAnimating = false;
                this.startTime = null;
                this.timerInterval = null;
                this.diskColors = [
                    'linear-gradient(45deg, #FF6B6B, #FF8E8E)',
                    'linear-gradient(45deg, #4ECDC4, #7FDBDA)',
                    'linear-gradient(45deg, #45B7D1, #96CEB4)',
                    'linear-gradient(45deg, #FFA07A, #FFB347)',
                    'linear-gradient(45deg, #98D8C8, #F7DC6F)',
                    'linear-gradient(45deg, #BB8FCE, #D7BDE2)',
                    'linear-gradient(45deg, #F8C471, #F9E79F)',
                    'linear-gradient(45deg, #85C1E9, #AED6F1)',
                    'linear-gradient(45deg, #F1948A, #F8BBD9)',
                    'linear-gradient(45deg, #82E0AA, #A9DFBF)',
                    'linear-gradient(45deg, #F7DC6F, #F4D03F)',
                    'linear-gradient(45deg, #AED6F1, #85C1E9)',
                    'linear-gradient(45deg, #D7BDE2, #BB8FCE)',
                    'linear-gradient(45deg, #F9E79F, #F8C471)',
                    'linear-gradient(45deg, #7FDBDA, #4ECDC4)'
                ];
                
                this.initializeEventListeners();
                this.reset();
            }

            initializeEventListeners() {
                document.getElementById('solveBtn').addEventListener('click', () => this.solve());
                document.getElementById('resetBtn').addEventListener('click', () => this.reset());
                document.getElementById('stepBtn').addEventListener('click', () => this.nextStep());
                document.getElementById('diskCount').addEventListener('change', () => this.reset());

            }



            reset() {
                this.stopTimer();
                this.towers = { A: [], B: [], C: [] };
                this.moves = [];
                this.currentMoveIndex = 0;
                this.moveCount = 0;
                this.isAnimating = false;
                
                const diskCount = parseInt(document.getElementById('diskCount').value);
                
                // Initialize tower A with disks (largest to smallest from bottom to top)
                for (let i = diskCount; i >= 1; i--) {
                    this.towers.A.push(i);
                }
                
                this.updateDisplay();
                this.updateStats();
                
                // Enable/disable buttons
                document.getElementById('solveBtn').disabled = false;
                document.getElementById('stepBtn').disabled = true;
            }

            solve() {
                if (this.isAnimating) return;
                
                const diskCount = parseInt(document.getElementById('diskCount').value);
                this.moves = [];
                this.solveTowerOfHanoi(diskCount, 'A', 'C', 'B');
                
                // Start automatic solving
                document.getElementById('solveBtn').disabled = true;
                document.getElementById('stepBtn').disabled = false;
                this.startTimer();
                this.animateSolution();
            }

            solveTowerOfHanoi(n, source, destination, auxiliary) {
                if (n === 1) {
                    this.moves.push({ from: source, to: destination, disk: 1 });
                } else {
                    // Move n-1 disks from source to auxiliary
                    this.solveTowerOfHanoi(n - 1, source, auxiliary, destination);
                    
                    // Move the largest disk from source to destination
                    this.moves.push({ from: source, to: destination, disk: n });
                    
                    // Move n-1 disks from auxiliary to destination
                    this.solveTowerOfHanoi(n - 1, auxiliary, destination, source);
                }
            }

            async animateSolution() {
                const speed = parseInt(document.getElementById('speed').value);
                this.isAnimating = true;
                
                for (let i = 0; i < this.moves.length; i++) {
                    // Check if animation was interrupted (e.g., by reset)
                    if (!this.isAnimating) {
                        break;
                    }
                    
                    await this.animateMove(this.moves[i], i);
                    await this.delay(speed);
                }
                
                // Only disable solve button if we completed the animation
                if (this.isAnimating) {
                    this.isAnimating = false;
                    this.stopTimer();
                    document.getElementById('solveBtn').disabled = false;
                }
            }

            async animateMove(move, moveIndex) {
                const { from, to } = move;
                
                // Get the disk to move
                const disk = this.towers[from].pop();
                const diskElement = this.getDiskElement(from, this.towers[from].length);
                
                // Animate the move
                if (diskElement) {
                    diskElement.classList.add('moving');
                    await this.delay(250);
                    diskElement.classList.remove('moving');
                }
                
                // Move the disk to destination
                this.towers[to].push(disk);
                this.moveCount++;
                
                this.updateDisplay();
                this.updateStats();
            }

            nextStep() {
                if (this.currentMoveIndex < this.moves.length) {
                    const move = this.moves[this.currentMoveIndex];
                    this.animateMove(move, this.currentMoveIndex);
                    this.currentMoveIndex++;
                    
                    if (this.currentMoveIndex >= this.moves.length) {
                        document.getElementById('stepBtn').disabled = true;
                        this.stopTimer();
                    }
                }
            }

            getDiskElement(tower, index) {
                const towerElement = document.getElementById(\`tower-\${tower}\`);
                const towerContent = towerElement.querySelector('.tower-content');
                const diskElements = towerContent.querySelectorAll('.disk');
                return diskElements[index];
            }

            updateDisplay() {
                // Clear all towers
                ['A', 'B', 'C'].forEach(towerName => {
                    const tower = document.getElementById(\`tower-\${towerName}\`);
                    const existingDisks = tower.querySelectorAll('.disk');
                    existingDisks.forEach(disk => disk.remove());
                });

                // Render disks on each tower
                ['A', 'B', 'C'].forEach(towerName => {
                    const tower = document.getElementById(\`tower-\${towerName}\`);
                    const towerContent = tower.querySelector('.tower-content');
                    const towerDisks = this.towers[towerName];
                    
                    towerDisks.forEach((diskSize, index) => {
                        const disk = document.createElement('div');
                        disk.className = 'disk';
                        disk.style.width = \`\${40 + diskSize * 10}px\`;
                        disk.style.background = this.diskColors[diskSize - 1];
                        disk.textContent = diskSize;
                        
                        // Insert disk into tower content (before the base)
                        const base = towerContent.querySelector('.tower-base');
                        towerContent.insertBefore(disk, base);
                    });
                });
            }

            updateStats() {
                document.getElementById('moveCount').textContent = this.moveCount;
                const diskCount = parseInt(document.getElementById('diskCount').value);
                document.getElementById('minMoves').textContent = Math.pow(2, diskCount) - 1;
            }







            startTimer() {
                this.startTime = Date.now();
                this.timerInterval = setInterval(() => {
                    const elapsed = Math.floor((Date.now() - this.startTime) / 1000);
                    document.getElementById('totalTime').textContent = elapsed;
                }, 1000);
            }

            stopTimer() {
                if (this.timerInterval) {
                    clearInterval(this.timerInterval);
                    this.timerInterval = null;
                }
            }

            delay(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }
        }

        // Initialize the game when the page loads
        window.addEventListener('DOMContentLoaded', () => {
            new TowerOfHanoi();
        });
    </script>
</body>
</html>`}
    width="100%"
    height="1000px"
    style={{ border: 'none', borderRadius: '8px', boxShadow: '0 4px 6px rgba(0, 0, 0, 0.1)' }}
    title="Tower of Hanoi Algorithmic Solver"
  />
</div>

**Tower of Hanoi Recursive Algorithm:**

```javascript
// This is the core recursive algorithm for solving Tower of Hanoi
solveTowerOfHanoi(n, source, destination, auxiliary) {
    // BASE CASE: If there's only 1 disk, move it directly
    if (n === 1) {
        this.moves.push({ 
            from: source, 
            to: destination, 
            disk: 1 
        });
    } else {
        // RECURSIVE CASE: Break down the problem into 3 steps
        
        // Step 1: Move n-1 disks from source to auxiliary tower
        // (using destination as temporary storage)
        this.solveTowerOfHanoi(n - 1, source, auxiliary, destination);
        
        // Step 2: Move the largest disk from source to destination
        this.moves.push({ 
            from: source, 
            to: destination, 
            disk: n 
        });
        
        // Step 3: Move n-1 disks from auxiliary to destination
        // (using source as temporary storage)
        this.solveTowerOfHanoi(n - 1, auxiliary, destination, source);
    }
}
```

## Understanding the relationship

Understanding the relationship between memorization, generalization and reasoning is critical for:

### 1. Evaluation Design
Tests that expect memorized responses miss models that have progressed to generalization and reasoning. When evaluations reward exhaustive approaches (like move lists), they penalize models that have learned to think abstractly and generate practical engineering solutions.

### 2. Capability Unlocking
Reasoning "failures" often stem from poor evaluation design. Tweaking task setup or prompts can reveal genuine capabilities valuable for workflow automation, coding, and information extraction. Additionally, understanding when models move from memorization to generalization can help us in areas of efficiency and intelligence.

### 3. Tool Integration
LLMs should be paired with tools to augment reasoning. In our experiments, Claude Opus solved Tower of Hanoi through recursive algorithms, not exhaustive move enumeration.

## Conclusion

Models are generalizing effectively and knowing at what points helps us iterate on intelligence. With proper prompts, tools, and evaluation frameworks, models demonstrate stronger reasoning than flawed tests suggest. While not yet human-level reasoners, the future isn't as bleak as some evaluations indicate. The "collapse" often reflects our testing limitations, not fundamental model constraints.

Understanding these distinctions is crucial for determining where innovation is truly needed versus where better implementation can unlock existing capabilities.
