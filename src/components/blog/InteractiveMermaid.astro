---
/**
 * InteractiveMermaid - A wrapper component for Mermaid diagrams with zoom/pan functionality.
 *
 * Usage in MDX:
 * <InteractiveMermaid chart={`
 *   flowchart LR
 *     A --> B
 * `} />
 */
interface Props {
  /** Mermaid diagram code */
  chart: string;
  /** Initial zoom level (default: 1) */
  initialZoom?: number;
  /** Minimum zoom level (default: 0.5) */
  minZoom?: number;
  /** Maximum zoom level (default: 3) */
  maxZoom?: number;
  /** Height of the container (default: 600px) */
  height?: string;
}

const {
  chart,
  initialZoom = 1,
  minZoom = 0.5,
  maxZoom = 3,
  height = "600px",
} = Astro.props;
---

<div
  class="interactive-mermaid-container"
  data-initial-zoom={initialZoom}
  data-min-zoom={minZoom}
  data-max-zoom={maxZoom}
  data-chart={chart}
>
  <div class="mermaid-controls">
    <button class="zoom-btn zoom-in" title="Zoom In" aria-label="Zoom in">
      <svg
        xmlns="http://www.w3.org/2000/svg"
        width="20"
        height="20"
        viewBox="0 0 24 24"
        fill="none"
        stroke="currentColor"
        stroke-width="2"
        stroke-linecap="round"
        stroke-linejoin="round"
      >
        <circle cx="11" cy="11" r="8"></circle>
        <line x1="21" y1="21" x2="16.65" y2="16.65"></line>
        <line x1="11" y1="8" x2="11" y2="14"></line>
        <line x1="8" y1="11" x2="14" y2="11"></line>
      </svg>
    </button>
    <button class="zoom-btn zoom-out" title="Zoom Out" aria-label="Zoom out">
      <svg
        xmlns="http://www.w3.org/2000/svg"
        width="20"
        height="20"
        viewBox="0 0 24 24"
        fill="none"
        stroke="currentColor"
        stroke-width="2"
        stroke-linecap="round"
        stroke-linejoin="round"
      >
        <circle cx="11" cy="11" r="8"></circle>
        <line x1="21" y1="21" x2="16.65" y2="16.65"></line>
        <line x1="8" y1="11" x2="14" y2="11"></line>
      </svg>
    </button>
    <button class="zoom-btn zoom-reset" title="Reset View" aria-label="Reset view">
      <svg
        xmlns="http://www.w3.org/2000/svg"
        width="20"
        height="20"
        viewBox="0 0 24 24"
        fill="none"
        stroke="currentColor"
        stroke-width="2"
        stroke-linecap="round"
        stroke-linejoin="round"
      >
        <path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"></path>
        <path d="M3 3v5h5"></path>
      </svg>
    </button>
    <button class="zoom-btn zoom-fit" title="Fit to View" aria-label="Fit to view">
      <svg
        xmlns="http://www.w3.org/2000/svg"
        width="20"
        height="20"
        viewBox="0 0 24 24"
        fill="none"
        stroke="currentColor"
        stroke-width="2"
        stroke-linecap="round"
        stroke-linejoin="round"
      >
        <path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"
        ></path>
      </svg>
    </button>
    <span class="zoom-level">100%</span>
  </div>
  <div class="mermaid-hint">
    <span>Scroll to zoom â€¢ Drag to pan</span>
  </div>
  <div class="mermaid-viewport" style={`height: ${height};`}>
    <div class="mermaid-content">
      <div class="mermaid-render"></div>
    </div>
  </div>
</div>

<style>
  .interactive-mermaid-container {
    position: relative;
    border: 1px solid var(--ctp-surface0, #313244);
    border-radius: 0.75rem;
    background: var(--ctp-mantle, #181825);
    overflow: hidden;
    margin: 1.5rem 0;
  }

  .mermaid-controls {
    display: flex;
    gap: 0.5rem;
    padding: 0.75rem;
    background: var(--ctp-base, #1e1e2e);
    border-bottom: 1px solid var(--ctp-surface0, #313244);
    align-items: center;
  }

  .zoom-btn {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 36px;
    height: 36px;
    border: 1px solid var(--ctp-surface1, #45475a);
    border-radius: 0.5rem;
    background: var(--ctp-surface0, #313244);
    color: var(--ctp-text, #cdd6f4);
    cursor: pointer;
    transition: all 0.2s ease;
  }

  .zoom-btn:hover {
    background: var(--ctp-surface1, #45475a);
    border-color: var(--ctp-blue, #89b4fa);
    color: var(--ctp-blue, #89b4fa);
  }

  .zoom-btn:active {
    transform: scale(0.95);
  }

  .zoom-level {
    margin-left: 0.5rem;
    padding: 0.25rem 0.75rem;
    font-size: 0.875rem;
    font-weight: 500;
    color: var(--ctp-subtext1, #bac2de);
    background: var(--ctp-surface0, #313244);
    border-radius: 0.375rem;
    min-width: 60px;
    text-align: center;
  }

  .mermaid-hint {
    position: absolute;
    top: 60px;
    right: 12px;
    z-index: 10;
    padding: 0.375rem 0.75rem;
    font-size: 0.75rem;
    color: var(--ctp-subtext0, #a6adc8);
    background: var(--ctp-surface0, #313244);
    border-radius: 0.375rem;
    opacity: 0.8;
    pointer-events: none;
    transition: opacity 0.3s ease;
  }

  .interactive-mermaid-container:hover .mermaid-hint {
    opacity: 0;
  }

  .mermaid-viewport {
    overflow: hidden;
    cursor: grab;
    background: radial-gradient(
      ellipse at center,
      var(--ctp-base, #1e1e2e) 0%,
      var(--ctp-mantle, #181825) 100%
    );
  }

  .mermaid-viewport:active {
    cursor: grabbing;
  }

  .mermaid-content {
    display: flex;
    align-items: center;
    justify-content: center;
    min-width: 100%;
    min-height: 100%;
    padding: 2rem;
    transform-origin: center center;
  }

  /* Override mermaid SVG styles for better visibility */
  .mermaid-content :global(svg) {
    max-width: none !important;
    height: auto !important;
  }

  /* Force dark text on nodes with colored backgrounds for readability */
  .mermaid-content :global(.node .nodeLabel),
  .mermaid-content :global(.node .nodeLabel p) {
    color: #1e1e2e !important;
  }

  /* Remove edge label background boxes for cleaner appearance */
  .mermaid-content :global(.labelBkg) {
    background-color: transparent !important;
  }

  /* Light theme adjustments */
  :global([data-theme="latte"]) .interactive-mermaid-container {
    border-color: var(--ctp-surface0, #ccd0da);
    background: var(--ctp-mantle, #e6e9ef);
  }

  :global([data-theme="latte"]) .mermaid-controls {
    background: var(--ctp-base, #eff1f5);
    border-color: var(--ctp-surface0, #ccd0da);
  }

  :global([data-theme="latte"]) .mermaid-viewport {
    background: radial-gradient(
      ellipse at center,
      var(--ctp-base, #eff1f5) 0%,
      var(--ctp-mantle, #e6e9ef) 100%
    );
  }
</style>

<script>
  interface PanZoomInstance {
    getTransform: () => { scale: number; x: number; y: number };
    zoomAbs: (x: number, y: number, scale: number) => void;
    moveTo: (x: number, y: number) => void;
    dispose: () => void;
    on: (event: string, callback: () => void) => void;
  }

  interface PanZoomOptions {
    maxZoom: number;
    minZoom: number;
    zoomSpeed: number;
    smoothScroll: boolean;
  }

  interface MermaidAPI {
    initialize: (config: Record<string, unknown>) => void;
    render: (id: string, code: string) => Promise<{ svg: string }>;
  }

  declare function panzoom(
    element: HTMLElement,
    options: PanZoomOptions
  ): PanZoomInstance;

  declare const mermaid: MermaidAPI;

  let mermaidIdCounter = 0;

  async function renderMermaidCharts() {
    const containers = document.querySelectorAll<HTMLElement>(
      ".interactive-mermaid-container"
    );

    // Initialize mermaid with dark theme support
    const isDarkTheme = document.documentElement.getAttribute("data-theme") !== "latte";
    mermaid.initialize({
      startOnLoad: false,
      theme: isDarkTheme ? "dark" : "default",
      themeVariables: isDarkTheme ? {
        primaryColor: "#89b4fa",
        primaryTextColor: "#cdd6f4",
        primaryBorderColor: "#45475a",
        lineColor: "#bac2de",
        secondaryColor: "#313244",
        tertiaryColor: "#1e1e2e",
        background: "#1e1e2e",
        mainBkg: "#313244",
        nodeBorder: "#585b70",
        clusterBkg: "transparent",
        clusterBorder: "#7f849c",
        titleColor: "#cdd6f4",
        edgeLabelBackground: "transparent",
      } : {
        primaryColor: "#1e66f5",
        primaryTextColor: "#4c4f69",
        primaryBorderColor: "#ccd0da",
        lineColor: "#6c6f85",
        secondaryColor: "#ccd0da",
        tertiaryColor: "#eff1f5",
        background: "#eff1f5",
        mainBkg: "#ccd0da",
        nodeBorder: "#ccd0da",
        clusterBkg: "#e6e9ef",
        clusterBorder: "#ccd0da",
        titleColor: "#4c4f69",
        edgeLabelBackground: "transparent",
      },
    });

    for (const container of containers) {
      const chartCode = container.dataset.chart;
      const renderTarget = container.querySelector<HTMLElement>(".mermaid-render");

      if (!chartCode || !renderTarget) continue;

      try {
        const uniqueId = `mermaid-${mermaidIdCounter++}`;
        const { svg } = await mermaid.render(uniqueId, chartCode);
        renderTarget.innerHTML = svg;
      } catch (error) {
        console.error("Failed to render Mermaid chart:", error);
        renderTarget.innerHTML = `<pre style="color: var(--ctp-red, #f38ba8); padding: 1rem;">Error rendering diagram: ${error}</pre>`;
      }
    }
  }

  function initializePanzoom() {
    const containers = document.querySelectorAll<HTMLElement>(
      ".interactive-mermaid-container"
    );

    containers.forEach((container) => {
      const viewport = container.querySelector<HTMLElement>(".mermaid-viewport");
      const content = container.querySelector<HTMLElement>(".mermaid-content");
      const zoomInBtn = container.querySelector<HTMLButtonElement>(".zoom-in");
      const zoomOutBtn = container.querySelector<HTMLButtonElement>(".zoom-out");
      const zoomResetBtn =
        container.querySelector<HTMLButtonElement>(".zoom-reset");
      const zoomFitBtn = container.querySelector<HTMLButtonElement>(".zoom-fit");
      const zoomLevelSpan =
        container.querySelector<HTMLSpanElement>(".zoom-level");

      if (!viewport || !content) return;

      const initialZoom = parseFloat(container.dataset.initialZoom || "1");
      const minZoom = parseFloat(container.dataset.minZoom || "0.5");
      const maxZoom = parseFloat(container.dataset.maxZoom || "3");

      // Initialize panzoom
      const pz = panzoom(content, {
        maxZoom: maxZoom,
        minZoom: minZoom,
        zoomSpeed: 0.065,
        smoothScroll: false,
      });

      // Update zoom level display
      function updateZoomLevel() {
        const transform = pz.getTransform();
        const percentage = Math.round(transform.scale * 100);
        if (zoomLevelSpan) {
          zoomLevelSpan.textContent = `${percentage}%`;
        }
      }

      pz.on("zoom", updateZoomLevel);
      pz.on("transform", updateZoomLevel);

      // Zoom controls
      zoomInBtn?.addEventListener("click", () => {
        const transform = pz.getTransform();
        const newScale = Math.min(transform.scale * 1.25, maxZoom);
        const rect = viewport.getBoundingClientRect();
        const cx = rect.width / 2;
        const cy = rect.height / 2;
        pz.zoomAbs(cx, cy, newScale);
      });

      zoomOutBtn?.addEventListener("click", () => {
        const transform = pz.getTransform();
        const newScale = Math.max(transform.scale / 1.25, minZoom);
        const rect = viewport.getBoundingClientRect();
        const cx = rect.width / 2;
        const cy = rect.height / 2;
        pz.zoomAbs(cx, cy, newScale);
      });

      zoomResetBtn?.addEventListener("click", () => {
        const rect = viewport.getBoundingClientRect();
        const cx = rect.width / 2;
        const cy = rect.height / 2;
        pz.zoomAbs(cx, cy, initialZoom);
        // Center the content
        const contentRect = content.getBoundingClientRect();
        const offsetX = (rect.width - contentRect.width * initialZoom) / 2;
        const offsetY = (rect.height - contentRect.height * initialZoom) / 2;
        pz.moveTo(offsetX, offsetY);
      });

      // Fit to view function - reusable for button and auto-fit
      function fitToView() {
        const svg = content.querySelector("svg");
        if (!svg) return;

        const viewportRect = viewport.getBoundingClientRect();
        const svgRect = svg.getBoundingClientRect();
        const transform = pz.getTransform();

        // Calculate the actual SVG dimensions at scale 1
        const svgWidth = svgRect.width / transform.scale;
        const svgHeight = svgRect.height / transform.scale;

        // Calculate scale to fit with some padding
        const padding = 40;
        const scaleX = (viewportRect.width - padding) / svgWidth;
        const scaleY = (viewportRect.height - padding) / svgHeight;
        const fitScale = Math.min(scaleX, scaleY, maxZoom);
        const clampedScale = Math.max(fitScale, minZoom);

        // Apply fit zoom
        const cx = viewportRect.width / 2;
        const cy = viewportRect.height / 2;
        pz.zoomAbs(cx, cy, clampedScale);

        // Center after zoom
        setTimeout(() => {
          const newSvgRect = svg.getBoundingClientRect();
          const newViewportRect = viewport.getBoundingClientRect();
          const offsetX =
            (newViewportRect.width - newSvgRect.width) / 2 -
            (newSvgRect.left - newViewportRect.left);
          const offsetY =
            (newViewportRect.height - newSvgRect.height) / 2 -
            (newSvgRect.top - newViewportRect.top);
          const currentTransform = pz.getTransform();
          pz.moveTo(currentTransform.x + offsetX, currentTransform.y + offsetY);
          updateZoomLevel();
        }, 50);
      }

      zoomFitBtn?.addEventListener("click", fitToView);

      // Auto-fit on load after a short delay to ensure SVG is rendered
      setTimeout(fitToView, 100);
    });
  }

  // Load external libraries
  function loadScript(src: string): Promise<void> {
    return new Promise((resolve, reject) => {
      const existing = document.querySelector(`script[src="${src}"]`);
      if (existing) {
        resolve();
        return;
      }
      const script = document.createElement("script");
      script.src = src;
      script.onload = () => resolve();
      script.onerror = () => reject(new Error(`Failed to load ${src}`));
      document.head.appendChild(script);
    });
  }

  async function initializeAll() {
    try {
      // Load both libraries
      await Promise.all([
        loadScript("https://unpkg.com/panzoom@9.4.3/dist/panzoom.min.js"),
        loadScript("https://cdn.jsdelivr.net/npm/mermaid@11/dist/mermaid.min.js"),
      ]);

      // First render the charts, then initialize panzoom
      await renderMermaidCharts();
      initializePanzoom();
    } catch (error) {
      console.error("Failed to initialize InteractiveMermaid:", error);
    }
  }

  // Initialize when DOM is ready
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", initializeAll);
  } else {
    initializeAll();
  }
</script>
