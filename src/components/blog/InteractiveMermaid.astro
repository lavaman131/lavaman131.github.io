---
/**
 * InteractiveMermaid - A wrapper component for Mermaid diagrams with zoom/pan functionality.
 *
 * Usage in MDX:
 * <InteractiveMermaid>
 *   Your mermaid diagram code block
 * </InteractiveMermaid>
 */
interface Props {
  /** Initial zoom level (default: 1) */
  initialZoom?: number;
  /** Minimum zoom level (default: 0.5) */
  minZoom?: number;
  /** Maximum zoom level (default: 3) */
  maxZoom?: number;
  /** Height of the container (default: 600px) */
  height?: string;
}

const {
  initialZoom = 1,
  minZoom = 0.5,
  maxZoom = 3,
  height = "600px",
} = Astro.props;
---

<div
  class="interactive-mermaid-container"
  data-initial-zoom={initialZoom}
  data-min-zoom={minZoom}
  data-max-zoom={maxZoom}
>
  <div class="mermaid-controls">
    <button class="zoom-btn zoom-in" title="Zoom In" aria-label="Zoom in">
      <svg
        xmlns="http://www.w3.org/2000/svg"
        width="20"
        height="20"
        viewBox="0 0 24 24"
        fill="none"
        stroke="currentColor"
        stroke-width="2"
        stroke-linecap="round"
        stroke-linejoin="round"
      >
        <circle cx="11" cy="11" r="8"></circle>
        <line x1="21" y1="21" x2="16.65" y2="16.65"></line>
        <line x1="11" y1="8" x2="11" y2="14"></line>
        <line x1="8" y1="11" x2="14" y2="11"></line>
      </svg>
    </button>
    <button class="zoom-btn zoom-out" title="Zoom Out" aria-label="Zoom out">
      <svg
        xmlns="http://www.w3.org/2000/svg"
        width="20"
        height="20"
        viewBox="0 0 24 24"
        fill="none"
        stroke="currentColor"
        stroke-width="2"
        stroke-linecap="round"
        stroke-linejoin="round"
      >
        <circle cx="11" cy="11" r="8"></circle>
        <line x1="21" y1="21" x2="16.65" y2="16.65"></line>
        <line x1="8" y1="11" x2="14" y2="11"></line>
      </svg>
    </button>
    <button class="zoom-btn zoom-reset" title="Reset View" aria-label="Reset view">
      <svg
        xmlns="http://www.w3.org/2000/svg"
        width="20"
        height="20"
        viewBox="0 0 24 24"
        fill="none"
        stroke="currentColor"
        stroke-width="2"
        stroke-linecap="round"
        stroke-linejoin="round"
      >
        <path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"></path>
        <path d="M3 3v5h5"></path>
      </svg>
    </button>
    <button class="zoom-btn zoom-fit" title="Fit to View" aria-label="Fit to view">
      <svg
        xmlns="http://www.w3.org/2000/svg"
        width="20"
        height="20"
        viewBox="0 0 24 24"
        fill="none"
        stroke="currentColor"
        stroke-width="2"
        stroke-linecap="round"
        stroke-linejoin="round"
      >
        <path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"
        ></path>
      </svg>
    </button>
    <span class="zoom-level">100%</span>
  </div>
  <div class="mermaid-hint">
    <span>Scroll to zoom â€¢ Drag to pan</span>
  </div>
  <div class="mermaid-viewport" style={`height: ${height};`}>
    <div class="mermaid-content">
      <slot />
    </div>
  </div>
</div>

<style>
  .interactive-mermaid-container {
    position: relative;
    border: 1px solid var(--ctp-surface0, #313244);
    border-radius: 0.75rem;
    background: var(--ctp-mantle, #181825);
    overflow: hidden;
    margin: 1.5rem 0;
  }

  .mermaid-controls {
    display: flex;
    gap: 0.5rem;
    padding: 0.75rem;
    background: var(--ctp-base, #1e1e2e);
    border-bottom: 1px solid var(--ctp-surface0, #313244);
    align-items: center;
  }

  .zoom-btn {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 36px;
    height: 36px;
    border: 1px solid var(--ctp-surface1, #45475a);
    border-radius: 0.5rem;
    background: var(--ctp-surface0, #313244);
    color: var(--ctp-text, #cdd6f4);
    cursor: pointer;
    transition: all 0.2s ease;
  }

  .zoom-btn:hover {
    background: var(--ctp-surface1, #45475a);
    border-color: var(--ctp-blue, #89b4fa);
    color: var(--ctp-blue, #89b4fa);
  }

  .zoom-btn:active {
    transform: scale(0.95);
  }

  .zoom-level {
    margin-left: 0.5rem;
    padding: 0.25rem 0.75rem;
    font-size: 0.875rem;
    font-weight: 500;
    color: var(--ctp-subtext1, #bac2de);
    background: var(--ctp-surface0, #313244);
    border-radius: 0.375rem;
    min-width: 60px;
    text-align: center;
  }

  .mermaid-hint {
    position: absolute;
    top: 60px;
    right: 12px;
    z-index: 10;
    padding: 0.375rem 0.75rem;
    font-size: 0.75rem;
    color: var(--ctp-subtext0, #a6adc8);
    background: var(--ctp-surface0, #313244);
    border-radius: 0.375rem;
    opacity: 0.8;
    pointer-events: none;
    transition: opacity 0.3s ease;
  }

  .interactive-mermaid-container:hover .mermaid-hint {
    opacity: 0;
  }

  .mermaid-viewport {
    overflow: hidden;
    cursor: grab;
    background: radial-gradient(
      ellipse at center,
      var(--ctp-base, #1e1e2e) 0%,
      var(--ctp-mantle, #181825) 100%
    );
  }

  .mermaid-viewport:active {
    cursor: grabbing;
  }

  .mermaid-content {
    display: flex;
    align-items: center;
    justify-content: center;
    min-width: 100%;
    min-height: 100%;
    padding: 2rem;
    transform-origin: center center;
  }

  /* Override mermaid SVG styles for better visibility */
  .mermaid-content :global(svg) {
    max-width: none !important;
    height: auto !important;
  }

  /* Light theme adjustments */
  :global([data-theme="latte"]) .interactive-mermaid-container {
    border-color: var(--ctp-surface0, #ccd0da);
    background: var(--ctp-mantle, #e6e9ef);
  }

  :global([data-theme="latte"]) .mermaid-controls {
    background: var(--ctp-base, #eff1f5);
    border-color: var(--ctp-surface0, #ccd0da);
  }

  :global([data-theme="latte"]) .mermaid-viewport {
    background: radial-gradient(
      ellipse at center,
      var(--ctp-base, #eff1f5) 0%,
      var(--ctp-mantle, #e6e9ef) 100%
    );
  }
</style>

<script>
  interface PanZoomInstance {
    getTransform: () => { scale: number; x: number; y: number };
    zoomAbs: (x: number, y: number, scale: number) => void;
    moveTo: (x: number, y: number) => void;
    dispose: () => void;
    on: (event: string, callback: () => void) => void;
  }

  interface PanZoomOptions {
    maxZoom: number;
    minZoom: number;
    zoomSpeed: number;
    smoothScroll: boolean;
  }

  declare function panzoom(
    element: HTMLElement,
    options: PanZoomOptions
  ): PanZoomInstance;

  function initializeInteractiveMermaid() {
    const containers = document.querySelectorAll<HTMLElement>(
      ".interactive-mermaid-container"
    );

    containers.forEach((container) => {
      const viewport = container.querySelector<HTMLElement>(".mermaid-viewport");
      const content = container.querySelector<HTMLElement>(".mermaid-content");
      const zoomInBtn = container.querySelector<HTMLButtonElement>(".zoom-in");
      const zoomOutBtn = container.querySelector<HTMLButtonElement>(".zoom-out");
      const zoomResetBtn =
        container.querySelector<HTMLButtonElement>(".zoom-reset");
      const zoomFitBtn = container.querySelector<HTMLButtonElement>(".zoom-fit");
      const zoomLevelSpan =
        container.querySelector<HTMLSpanElement>(".zoom-level");

      if (!viewport || !content) return;

      const initialZoom = parseFloat(container.dataset.initialZoom || "1");
      const minZoom = parseFloat(container.dataset.minZoom || "0.5");
      const maxZoom = parseFloat(container.dataset.maxZoom || "3");

      // Initialize panzoom
      const pz = panzoom(content, {
        maxZoom: maxZoom,
        minZoom: minZoom,
        zoomSpeed: 0.065,
        smoothScroll: false,
      });

      // Update zoom level display
      function updateZoomLevel() {
        const transform = pz.getTransform();
        const percentage = Math.round(transform.scale * 100);
        if (zoomLevelSpan) {
          zoomLevelSpan.textContent = `${percentage}%`;
        }
      }

      pz.on("zoom", updateZoomLevel);
      pz.on("transform", updateZoomLevel);

      // Zoom controls
      zoomInBtn?.addEventListener("click", () => {
        const transform = pz.getTransform();
        const newScale = Math.min(transform.scale * 1.25, maxZoom);
        const rect = viewport.getBoundingClientRect();
        const cx = rect.width / 2;
        const cy = rect.height / 2;
        pz.zoomAbs(cx, cy, newScale);
      });

      zoomOutBtn?.addEventListener("click", () => {
        const transform = pz.getTransform();
        const newScale = Math.max(transform.scale / 1.25, minZoom);
        const rect = viewport.getBoundingClientRect();
        const cx = rect.width / 2;
        const cy = rect.height / 2;
        pz.zoomAbs(cx, cy, newScale);
      });

      zoomResetBtn?.addEventListener("click", () => {
        const rect = viewport.getBoundingClientRect();
        const cx = rect.width / 2;
        const cy = rect.height / 2;
        pz.zoomAbs(cx, cy, initialZoom);
        // Center the content
        const contentRect = content.getBoundingClientRect();
        const offsetX = (rect.width - contentRect.width * initialZoom) / 2;
        const offsetY = (rect.height - contentRect.height * initialZoom) / 2;
        pz.moveTo(offsetX, offsetY);
      });

      zoomFitBtn?.addEventListener("click", () => {
        const svg = content.querySelector("svg");
        if (!svg) return;

        const viewportRect = viewport.getBoundingClientRect();
        const svgRect = svg.getBoundingClientRect();
        const transform = pz.getTransform();

        // Calculate the actual SVG dimensions at scale 1
        const svgWidth = svgRect.width / transform.scale;
        const svgHeight = svgRect.height / transform.scale;

        // Calculate scale to fit
        const padding = 40;
        const scaleX = (viewportRect.width - padding) / svgWidth;
        const scaleY = (viewportRect.height - padding) / svgHeight;
        const fitScale = Math.min(scaleX, scaleY, maxZoom);
        const clampedScale = Math.max(fitScale, minZoom);

        // Apply fit zoom
        const cx = viewportRect.width / 2;
        const cy = viewportRect.height / 2;
        pz.zoomAbs(cx, cy, clampedScale);

        // Center after zoom
        setTimeout(() => {
          const newSvgRect = svg.getBoundingClientRect();
          const newViewportRect = viewport.getBoundingClientRect();
          const offsetX =
            (newViewportRect.width - newSvgRect.width) / 2 -
            (newSvgRect.left - newViewportRect.left);
          const offsetY =
            (newViewportRect.height - newSvgRect.height) / 2 -
            (newSvgRect.top - newViewportRect.top);
          const currentTransform = pz.getTransform();
          pz.moveTo(currentTransform.x + offsetX, currentTransform.y + offsetY);
        }, 50);
      });

      // Set initial zoom level display
      updateZoomLevel();
    });
  }

  // Load panzoom library
  function loadPanzoom(callback: () => void) {
    if (typeof panzoom !== "undefined") {
      callback();
      return;
    }

    const script = document.createElement("script");
    script.src =
      "https://unpkg.com/panzoom@9.4.3/dist/panzoom.min.js";
    script.onload = callback;
    script.onerror = () => console.error("Failed to load panzoom library");
    document.head.appendChild(script);
  }

  // Initialize when DOM is ready
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", () => {
      loadPanzoom(initializeInteractiveMermaid);
    });
  } else {
    loadPanzoom(initializeInteractiveMermaid);
  }
</script>
